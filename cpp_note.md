C++ 语言程序设计基础（郑莉）——笔记
===

- [C++ 语言程序设计基础（郑莉）——笔记](#c-语言程序设计基础郑莉笔记)
- [一、绪论](#一绪论)
  - [1. C++](#1-c)
  - [2. 面向对象](#2-面向对象)
  - [3. 编译](#3-编译)
  - [4. 翻译程序](#4-翻译程序)
- [二、C++ 简单程序设计（一）](#二c-简单程序设计一)
  - [1. 标识符](#1-标识符)
  - [2. 基本算术运算符](#2-基本算术运算符)
  - [3. 三目运算](#3-三目运算)
  - [4. `sizeof(class)` 类型名 或 `sizeof(expr)` 表达式](#4-sizeofclass-类型名-或-sizeofexpr-表达式)
  - [5. 位运算](#5-位运算)
  - [6. 运算优先级、类型转换](#6-运算优先级类型转换)
- [二、C++简单程序设计（二）](#二c简单程序设计二)
  - [1. 数据的输入和输出](#1-数据的输入和输出)
  - [2. 选择结构](#2-选择结构)
  - [3.循环结构](#3循环结构)
- [三、函数](#三函数)
  - [1. 函数定义](#1-函数定义)
  - [2. 函数调用](#2-函数调用)
  - [3. 嵌套与递归](#3-嵌套与递归)
  - [4. 函数的参数传递](#4-函数的参数传递)
  - [5. 引用类型](#5-引用类型)
  - [6. 含有可变参数的函数](#6-含有可变参数的函数)
  - [7. 内联函数](#7-内联函数)
  - [8. `constexpr`函数](#8-constexpr函数)
  - [9. 带默认参数值的函数](#9-带默认参数值的函数)
  - [10.函数重载](#10函数重载)
  - [11.C++系统函数](#11c系统函数)
- [四、类与对象](#四类与对象)
  - [1.面向对象程序的基本特点](#1面向对象程序的基本特点)
  - [2.类和对象](#2类和对象)
  - [3.构造函数](#3构造函数)
  - [4.析构函数](#4析构函数)
  - [5.类的组合](#5类的组合)
  - [6.UML简介](#6uml简介)
  - [7.结构体与联合体](#7结构体与联合体)
  - [8.枚举类](#8枚举类)

---

# 一、绪论

## 1. C++

**C++** 是高级语言，支持面向对象的观点和方法（将客观事物看作对象/对象间通过消息传送进行沟通）

## 2. 面向对象

- 对象
- 抽象与分类
- 封装
- 继承
- 多态（同样的消息作用在不同对象上有可能引起不同的行为）

## 3. 编译

- 源程序
- 目标程序（机器语言程序）
- 可执行程序（目标程序+库中的某些软件->可执行文件）

## 4. 翻译程序

- 汇编程序  
- 编译程序  
- 解释程序（边翻译边执行）

# 二、C++ 简单程序设计（一）

## 1. 标识符

- 以大写字母、小写字母或下划线 `_` 开始
- 可以由以大写字母、小写字母、下划线或数字 `0~9` 组成
- 大写字母和小写字母代表不同的标识符
- 不能是 **C++** 关键字或操作符

## 2. 基本算术运算符

- `+-*/`（若整数相除，结果取整）
- `%`（取余，操作数为整数）
  
优先级与结合性（先乘除，后加减，同级自左至右）
`++`，`--`（自增、自减） eg：`i++` ,`--j`

## 3. 三目运算

`expr1 ? expr2 : expr3;` 三目运算符优先级高于赋值运算符，低于逻辑运算符。
`expr1` 为 `bool` 类型，`expr2`、`expr3` 的类型可不同。

## 4. `sizeof(class)` 类型名 或 `sizeof(expr)` 表达式

"类型名" 所指定的类型，或 "表达式" 的结果类型所占的字节数

## 5. 位运算
- 按位与-将两个运算量的每一个位进行逻辑与操作
- 按位或-将两个运算量的每一个位进行逻辑或操作
- 按位疑惑-对应位相同，结果位为0；反之为1
- 按位取反
- 移位-左移（低位补0，高位舍弃）；右移（低位舍弃，高位无符号数补0有符号数补“符号位”）

## 6. 运算优先级、类型转换  
- 隐示转换
  - 将一个浮点数赋给整数类型时，结果值将只保留浮点数中的整数部分，小数部分将丢书
  - 将一个整数值赋给浮点类型时，小数部分记为0。如果整数所占的空间超过了浮点类型的容量，精度可能有损失
- 显示转换
  - 作用是将表达式的结果类型转换为类型说明符所指定的类型
  - 语法形式
    - 类型说明符 (`表达式`)
    - (`类型说明符`) 表达式
    - 类型转换操作符<`类型说明符`>（`表达式`）
    - `const_cast`、 `dynamic_cast`、 `reinterpret_cast`、 `static_cast`
  
# 二、C++简单程序设计（二）  

## 1. 数据的输入和输出
- `I/O流`
  - 在C++中将数据从一个对象到另一个对象的流动抽象为**流**。流在使用前要被建立，使用后要被删除。 
  - 数据的输入与输出是通过`I/O流`来实现的，`cin` 和 `cout` 是预定义的流类对象，`cin` 用来处理标准输入，即键盘输入。 `cout` 用来处理标准输出，即屏幕输出。
  - 从流中获取数据的操作称为**提取操作**，向流中添加数据的操作称为**插入操作**。  
- 预定义的插入符和提取符
  - ` “ << ” ` 是预定义的插入符，作用在流类对象`cout`上便可以实现向标准输出设备输出。
    - `cout << 表达式 << 表达式...` 
  - 标准输入是将提取符作用在流类对象`cin`上。
    - `cin >> 表达式 >> 表达式...`
  - 提取符可以连续写多个，每个后面跟一个表达式，该表达式通常是用于存放输入值的变量。例如：
    - `int a,b;`
    - `cin >> a >> b;`
## 2. 选择结构
- `if` 语句 
  - `if` (表达式)语句
  - `if` (表达式)语句1 `else` 语句2
  - `if` (表达式1)语句1  \n  `else if`（表达式2）语句2  \n  `else if`(表达式3)语句3  ...  \n  `else`语句n
- `switch` 语句
  - 语法形式
  - `switch(表达式)`
  - `{ case 常量表达式1: 语句1`
  - `  case 常量表达式2: 语句2`
  -        | 
  -        |
  -        |
  - `case 常量表达式n: 语句n`
  - `default:     语句 n+1`    
  - }
- 执行顺序
  - 以`case`中的常量表达式值为入口标号，由此开始顺序执行。因此，每个`case`分支最后应该加`break`语句。
- 注意
  - `case`分支可包含多个语句，且不用`{}`。
  - 表达式、判断值都是`int`或`char`型。
  - 如果若干分支执行内容相同可共用一组语句。      
## 3.循环结构
- `while`语句
  - 语法形式
    - `while(表达式)`语句（可以是*复合语句* ，其中必须含有改变*条件表达式*值的语句）
  - 执行顺序
    - 先判断表达式的值，若为`true`时，执行语句。
- `do-while`语句
  - 语法形式
    - `do`**语句**(可以是*复合语句* ，其中必须含有改变*条件表达式*值的语句)
    - `while`(表达式)
    - 执行顺序
      - 先执行循环体语句，后判断条件。
      - 表达式为`true`时，继续执行循环体。
- `for`语句
  - `for`*(初始语句【循环前先求解】 ; 表达式1【为true时执行循环体】 ; 表达式2【每次执行完循环体后求解】 )语句*
- 嵌套的控制结构、其他控制语句
  - 其他控制语句
    - `break`语句
      - 使程序从循环体和`switch`语句内跳出，继续执行逻辑上的下一条语句。不宜用在别处。
    - `continue`语句
      - 结束本次循环，接着判断是否执行下一次循环
    - `goto`语句
      - 使程序的执行流程跳转到语句标号所指定的语句。不提倡使用。
  
# 三、函数

## 1. 函数定义
- 语法形式
  -  类型标识符（1.表示返回值类型、由`return`语句给出返回值；2.若无返回值、写`void`，不必写`return`语句·） *函数名*(形式参数表)
  - {
  -    语句序列(最后一句是`return`语句)
  - }
## 2. 函数调用
- 函数调用
  - 调用函数需要先声明函数原型
    - 若函数定义在调用点之前，可以不另外声明；
    - 若函数定义在调用点之后，必须要在调用函数前声明函数原型；
    - 函数原型：类型标识符 被调用函数名(含类型说明的形参表)
  - 函数调用形式
    - 函数名(实参列表)
  - 嵌套调用
    - 在一个函数的函数体中，调用另一函数。
- 数制转换
## 3. 嵌套与递归 
- 递归调用
  - 函数直接或间接地调用自身，称为递归调用
## 4. 函数的参数传递
- 在函数被调用时才分配形参的存储单元
- 实参可以是常量、变量或表达式
- 值传递是传递参数值，即单向传递
- 引用传递可以实现双向传递
- 传引用作参数可以保障实参数据的安全
## 5. 引用类型
- 引用(**&**)是标识符的别名
- 定义一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象
- 一旦一个引用被初始化后，就不能改为指向其它对象
- 引用可以作为形参 
## 6. 含有可变参数的函数
- C++标准中提供了两种主要的方法
  - 如果所有的实参类型相同，可以传递一个名为`initializer_list`的标准库类型
  - 如果实参的类型不同，我们可以编写可变参数的模板
- `initializer_list`
  - `initializer_list`是一种标准库类型，用于表示某种特定类型的值的数组，该类型定义在同名的头文件中
  - `initializer_list`的使用方法
    - 是一个类模板
    - 使用模板时，需要在模板名字后面跟一对尖括号，括号内给出类型参数。
      - eg: `initializer_list<string> ls;//initializer_list的元素类型是string`
    - `initializer_list`比较特殊的一点是，其对象中的元素永远是常量值，我们无法改变`initializer_list`对象中元素的值
    - 含有`initializer_list`形参的函数也可以同时拥有其他形参
## 7. 内联函数
- 内联函数声明时使用关键字`inline`
  - 编译时在调用处用函数体进行替换；节省了参数传递；控制转移等开销
  - 内联函数体内不能有循环语句和`switch`语句
  - 内联函数的定义必须出现在内联函数第一次被调用之前
  - 对内联函数不能进行异常接口声明
## 8. `constexpr`函数
- `constexpr`函数语法规定
  - `constexpr`修饰的函数
    - 在其所有参数都是`constexpr`时一定返回`constexpr`
## 9. 带默认参数值的函数
- 可预先设置默认的参数值，调用时如给出实参，则采用实参值，否则采用预先设置的默认参数值。
- 默认参数值的说明次序
  - 有默认参数的形参必须列在形参列表的最右，即默认参数值的右面不能有无默认值的参数；
  - 调用时实参与形参的结合次序是从左向右。
## 10.函数重载
- 重载函数的形参必须不同：**个数**不同或**类型**不同。
- 编译程序将根据实参和形参的类型及个数的最佳匹配来选择调用哪一个函数。
- 不要将不同功能的函数声明为重载函数，以免出现调用结果的误解、混淆。
## 11.C++系统函数
- C++的系统库中提供了几百个函数可供程序员使用，例如：
  - 求平方根函数（`sprt`)
  - 求绝对值函数（`abs`）
- 使用系统函数时要包含相应的头文件，例如：
  - `cmath`库

# 四、类与对象

## 1.面向对象程序的基本特点
- 抽象
  - 对同一类对象的共同属性和行为进行概括，形成类
    - 首先注意问题的本质及描述，其次是实现过程或细节
    - 数据抽象：描述某类对象的属性或状态(对象相互区别的物理量)
    - 代码抽象：描述某类对象的共有的行为特征或具有的功能
    - 抽象的实现：类
- 封装
  - 将抽象出的数据、代码封装在一起，形成类
  - 将抽象出的数据成员、代码成员相结合，将它们视为一个整体
    - 目的：增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员
    - 实现封装：类声明中的{}
- 继承
  - 在已有类的基础上，进行扩展形成新的类
- 多态
  - 多态：同一名称，不同的功能实现方式
  - 目的：达到行为标识统一，减少程序中标识符的个数
## 2.类和对象
- 类是同一类对象的抽象，对象是类的实例
- 设计类就是设计类型
- 定义类
  - 为数据成员设置类内初始值
  - 用于初始化数据成员
  - 公有类型成员
    - 在关键字public后面声明，它们是类与外部的接口，任何外部函数都可以访问公有类型数据和函数
  - 私有类型成员
    - 在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问
    - 如果紧跟在类名称的后面声明私有成员，则关键字private可以省略
  - 保护类型成员
    - 与private类似，其差别表现在继承与派生时对派生类的影响不同
- 对象定义的语法
- 类名 对象名
- 类中成员之间直接使用成员名互相访问
- 从类外访问成员使用“对象名.成员名”方式访问public成员
- 类的成员函数
  - 在类中声明函数原型；
  - 可在类外给出函数体实现，并在函数名前使用类名加以限定；
  - 也可直接在类中给出函数体，形成内联成员函数；
  - 允许声明重载函数和带默认参数值的函数
- 内联成员函数
  - 为了提高运行时的效率，对于较简单的函数可声明为内联形式
  - 内联函数体中不要有复杂结构(如循环语句和`switch`语句)
  - 在类中声明内联成员函数的方式：
    - 将函数体放在类的声明中
    - 使用`inline`关键字
## 3.构造函数
- 构造函数的基本概念
  - 类中的特殊函数
  - 用于描述初始化算法
  - **构造函数的作用**
    - 在对象被创建时使用特定的值构造对象
    - 将对象*初始化*为一个特定的初始状态
  - **构造函数的形式**
    - 函数名与类名相同
    - 不能定义返回值类型，也不能有`return`语句
    - 可有形式参数，也可没有形式参数
    - 可以是内联函数
    - 可以重载
    - 可带默认参数值
  - **构造函数的调用时机**
    - 在对象创建时被自动调用
    - eg：`Clock myClock(0,0,0)`
  - **默认构造函数**
    - 调用时可以不需要实参的构造函数
      - 参数表为空的构造函数
      - 全部参数都有默认值的构造函数
  - **隐含生成的构造函数**
    - 如果程序中未定义构造函数，编译器将自动生成一个*默认构造函数*
      - 参数列表为空，不为数据成员设置初始值；
      - 如果类内定义了成员的初始值，则使用内类定义的初始值；
      - 如果没有定义类内的初始值，则以默认方式初始化；
      - 基本类型的数据默认初始化的值是不确定的。
  - **`=default`
    - 如果程序中已定义构造函数，默认情况下编译器就不再隐含生成默认构造函数。*如果此时依然希望编译器隐含生成默认构造函数，可以使用`"=default"`*。
- 委托构造函数
- 复制构造函数
  - 复制构造函数是一种特殊的构造函数，其形参为本类的对象引用。
  - 作用是用一个已存在的对象去初始化同类型的新对象。
   ```cpp
   class 类名{
   public:
   类名(形参);//构造函数
   类名(const 类名 &对象名);//复制构造函数  
   } 
   ```
  - 复制构造函数被调用的三种情况
    - 定义一个对象时，以本类另一个对象作为初始值，发生复制构造；
    - 如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造；
    - 如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用`return`语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。
      - 这种情况也可以通过移动构造避免不必要的复制
  - 隐含的复制构造函数
    - 如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个隐含的复制构造函数。
    - 这个构造函数执行的功能是：用初始值对象的每个数据成员，初始化将要建立的对象的对应数据成员。
  - `=delete`(如果不希望对象被复制构造)
    - C++98做法：将复制构造函数声明为`private`，并且不提供函数的实现。
    - C++11做法：*用"=delete"指示编译器不生成默认复制构造函数*
## 4.析构函数
- 析构函数完成对象被删除前的一些清理工作
- 在对象的生存期结束的时刻系统自动调用析构函数
- 如果程序中未声明析构函数，编译器将自动产生一个默认的析构函数，其函数体为空
  - 析构函数的原型  ~类名()；
  - 析构函数没有参数，没有返回类型
## 5.类的组合
- 组合的概念
  - 类中的成员是另一个类的对象
  - 可以在已有抽象的基础上实现更复杂的抽象
- **类组合的析构函数设计**
  - 原则：不仅要负责对本类中的基本类型成员数据初始化，也要对对象成员初始化。
  - 声明形式：
   ``` cpp
    类名::类名(对象成员所需的形参，本类成员形参)：
      对象1(参数)，对象2(参数)，......
    {
    //函数体其他语句  
    }    
   ``` 
- 构造组合类对象时的初始化次序
  - 首先对构造函数初始化列表中列出的成员（包括基本类型成员和对象成员）进行初始化，初始化次序是成员在类体中定义的次序。
    - 成员对象构造函数调用顺序：按对象成员的定义顺序，先声明者先构造。
    - 初始化列表中未出现的成员对象，调用默认构造函数（即无形参的）初始化
  - 处理完初始化列表之后，再执行构造函数的函数体
- 前向引用声明
  - 类应该先声明，后使用
  - 如果需要在某个类的声明之前，引用该类，则应进行前向引用声明
  - 前向引用声明只为程序引入一个标识符，但具体声明在其他地方
  - 前向引用声明注意事项
    - 在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类的对象。
    - 当使用前向引用声明时，只能使用被声明的符号，而不能涉及类的任何细节。
## 6.UML简介
- UML有三个基本的部分
  - 事物(Things)
  - 关系(Relationships)
  - 图(Diagrams)
- 包含关系——聚集
  - 共享聚集：部分可以参加多个整体
  - 组成聚集（组合）：整体拥有各个部分，整体与部分共存，如果整体不存在了，部分也就不存在了。
## 7.结构体与联合体
- 结构体
  - 结构体是一种特殊形态的类。
  - 与类的唯一区别：
    - 类的缺省访问权限是privte，结构体的缺省访问权限是public.
  - 什么时候用结构体而不用类
    - 定义主要用来保存数据、而没有什么操作的类型。
    - 人们习惯将结构体的数据成员设为公有，因此这时用结构体更方便。
  - 结构体定义
  ``` cpp
  struct 结构体名称{
          公有成员
  protected:
     保护型成员
  private:
     私有成员
  };
  ```
  - 结构体中可以有数据成员和函数成员
  - 结构体的初始化
  - 如果：
    - 一个结构体的全部数据成员都是公共成员；
    - 没有用户定义的构造函数；
    - 没有基类和虚函数
  - 这个结构体的变量可以用下面的语法形式初始化：
  - **类型名 变量名 = {成员数据1初值，成员数据2初值，......};**
- 联合体
  - 定义形式
  ```cpp
  union 联合体名称{
    公有成员
  protected:
    保护型成员
  private:
    私有成员  
  }；
  ```
  - 特点
    - 成员共用同一组内存单元
    - 任何两个成员不会同时有效
## 8.枚举类
- 枚举类定义
  - 语法形式
    - `enum class 枚举类型名:底层类型{枚举值列表}；`
- 枚举类的优势
  - 强作用域；
    - 其作用域限制在枚举类中。
  - 转换限制；
    - 枚举类对象不可以与整型隐式地互相转换。
  - 可以指定底层类型。

